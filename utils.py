import arviz as az
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

from sbi import utils as sbi_utils


###########
# custum SBI prior
########
## class SmoothedBoxPrior:
##   def __init__(self, low, high, sigma, device="cpu"):
##       """
##         theta_dim = 3
##         test = SmoothedBoxPrior(low=0.0  * torch.ones(theta_dim), 
##                                 high=1.0 * torch.ones(theta_dim), 
##                                 sigma=0.02 *torch.ones(theta_dim))
##         num_samples = 10_000
##         data = test.sample((num_samples,) )
##         plt.hist(data[:,0].numpy().flatten())
##         #
##         test = SmoothedBoxPrior(low=0.0*torch.ones(1), high=1.0 *torch.ones(1), sigma=0.02 *torch.ones(1))
##         x = torch.linspace(-1,2,50)
##         plt(x,torch.exp(test.log_prob(x)))
        
##       """
##       self.variance = sigma ** 2
##       self._center = (low + high) / 2.0
##       self._range  = (high - low) / 2.0
##       self.dist = sbi_utils.BoxUniform(low, high, device = device)

##   def log_prob(self, theta):
##       _theta_dist = torch.clip(torch.abs(theta - self._center) - self._range, 0, None)
##       return -0.5 * (_theta_dist ** 2 / self.variance + torch.log(2 * torch.pi * self.variance))

##   def sample(self, sample_shape):
##       """
##        Samples are taken from a hard uniform distribution between the bounds
##       """
##       samples = self.dist.sample(sample_shape)
##       return samples




############
def overplot_lines(axes, xs, reverse=False, **kwargs):
    """
    Overplot lines on a figure generated by ``corner.corner``
    Parameters
    ----------
    fig : Figure
        The figure generated by a call to :func:`corner.corner`.
    xs : array_like[ndim]
       The values where the lines should be plotted. This must have ``ndim``
       entries, where ``ndim`` is compatible with the :func:`corner.corner`
       call that originally generated the figure. The entries can optionally
       be ``None`` to omit the line in that axis.
    reverse: bool
       A boolean flag that should be set to 'True' if the corner plot itself
       was plotted with 'reverse=True'.
    **kwargs
        Any remaining keyword arguments are passed to the ``ax.axvline``
        method.
    """
    K = len(xs)
    if reverse:
        for k1 in range(K):
            if xs[k1] is not None:
                axes[K - k1 - 1, K - k1 - 1].axvline(xs[k1], **kwargs)
            for k2 in range(k1 + 1, K):
                if xs[k1] is not None:
                    axes[K - k2 - 1, K - k1 - 1].axvline(xs[k1], **kwargs)
                if xs[k2] is not None:
                    axes[K - k2 - 1, K - k1 - 1].axhline(xs[k2], **kwargs)

    else:
        for k1 in range(K):
            if xs[k1] is not None:
                axes[k1, k1].axvline(xs[k1], **kwargs)
            for k2 in range(k1 + 1, K):
                if xs[k1] is not None:
                    axes[k2, k1].axvline(xs[k1], **kwargs)
                if xs[k2] is not None:
                    axes[k2, k1].axhline(xs[k2], **kwargs)

def plot_params_kde(samples,hdi_probs=[0.393, 0.865, 0.989], 
                    patName=None, fname=None, pcut=None, reference_values=None, 
                    reference_color='k', label_size=10,labeller=None, limits=None,
                   var_names=None, point_estimate="median", figsize=(8,8)):
    """
     limts = [[min_1,max_1], ... , [min_N, max_N]] N varaibles
    """
        
    if pcut is not None:
        low = pcut[0]
        up  = pcut[1] 
        #keep only data in the [low, up] percentiles ex. 0.5, 99.5
        samples={name:value[(value>np.percentile(value,low)) &  (value<np.percentile(value,up))] \
          for name, value in samples.items()}
        len_min = np.min([len(value) for name, value in samples.items()])
        len_max = np.max([len(value) for name, value in samples.items()])
        if (len_max-len_min)>0.01*len_max:
            print(f"Warning: pcut leads to min/max spls size = {len_min}/{len_max}")
        samples = {name:value[:len_min] for name, value in samples.items()}
    
    axs= az.plot_pair(
            samples,
            var_names=var_names,
            kind="kde",
            labeller=labeller,
            figsize=figsize,
            marginal_kwargs={"plot_kwargs": {"linewidth": 2, "c": "b"}},
            kde_kwargs={
#                "hdi_probs": [0.68, 0.9],  # Plot 68% and 90% HDI contours
                "hdi_probs":hdi_probs,  # 1, 2 and 3 sigma contours
                "contour_kwargs":{"colors":('r', 'green', 'blue'), "linewidths":2},
                "contourf_kwargs":{"alpha":0},
            },
            point_estimate_kwargs={"lw": 2, "c": "b"},
            marginals=True, textsize=label_size, point_estimate=point_estimate,
            reference_values=reference_values, reference_values_kwargs={"c":reference_color}
        );
    
    if reference_values is not None:
      overplot_lines(axs,list(reference_values.values()), color=reference_color)
      if limits is not None:
        assert len(limits) == len(samples.keys()), "wrong number of limits"
        for i in range(0,axs.shape[0]):
          for j in range(0,i+1):
            if j == i:
              axs[i,i].set_xlim(limits[i])
            else:
              axs[i,j].set_xlim(limits[j])
              axs[i,j].set_ylim(limits[i])

    plt.tight_layout()
    
    if patName is not None:
#        patName_patch = mpatches.Patch(color='b', label=patName)
#        axs[0,0].legend(handles=[patName_patch], fontsize=40, bbox_to_anchor=(1, 0.7));
      fig = axs[0,0].get_figure()
      fig.suptitle(patName)
    if fname is not None:
        plt.savefig(fname)
        plt.close()
    else:
        plt.show();

########
import torch
import numpy as np
import random


# these functions exists in pyro.utils but are nor exposed to the users???
def set_rng_state(state):               
     torch.set_rng_state(state["torch"])
     random.setstate(state["random"])
     np.random.set_state(state["numpy"])

def get_rng_state():
    return {
        "torch": torch.get_rng_state(),
        "random": random.getstate(),
        "numpy": np.random.get_state(),
    }

